# RAM
기본적으로 `RAM`은 `실행할 대상`을 저장한다. 

그러므로 컴퓨터가 꺼지면 RAM에 기록된 실행할 대상에 대한 데이터들은 날라가게 된다.

전원이 꺼져도 저장되어야하는 데이터들에 대해서는 `보조기억장치`에 저장하여 이를 보완한다.

이것이 기본 RAM(휘발성) - 보조기억장치(비휘발성)의 서로의 역할에 대한 기본 개념이다.

## RAM의 용량과 성능

보조기억장치에 저장된 프로그램 A, B, C가 있다고 가정해보자.

만약 램 용량이 작아 위 셋 프로그램중 하나만 램에 저장할 수 있다면 

프로그램 A를 실행 중일 때 램에는 프로그램 A가 저장되어있을 것이고 CPU는 이를 통해 작업을 수행할 것이다.

만약 프로그램 B를 CPU가 필요로 할 경우에 램 용량이 넉넉치 않아 프로그램 B를 보조기억장치로부터 메모리에 올리고 나서 CPU 작업 수행이 가능하다.

반면 램 용량이 충분할 때는 A, B, C를 모두 램에 올려놓고 CPU는 동시에 A, B, C를 모두 사용 가능하다.

## 램의 종류

### DRAM(Dynamic RAM)

저장된 데이터가 **동적으로 사라지는** RAM을 말한다.

이 동적으로 사라진다는 표현은 컴퓨터에 전원이 들어와있어도 램에 저장된 데이터가 동적으로 사라지는 것을 뜻한다.

이 사라짐에 의해 데이터가 소멸되는 것을 막기 위해 주기적으로 데이터를 재활성화 해야한다.

### SRAM(Static RAM)

저장된 데이터가 **정적인** RAM을 말한다.

하지만 당연히 RAM이기에 전원을 빼면 데이터가 휘발되기는 한다. 

하지만 DRAM과 달리 전원이 켜진 가운데 데이터가 동적으로 사라지진 않는다.

일반적으로 SRAM이 DRAM보다 입출력속도가 더 빠르다.

일반적으로 캐시메모리에 SRAM이 사용된다.

### SRAM과 DRAM

DRAM은 집적도를 높게, 소비전력을 낮게 설계가 가능하다. 

SRAM은 집적도를 낮게, 소비전력을 높게 설계되어진다.

즉 DRAM을 SRAM보다 고용량으로, 상대적으로 저비용으로 만들어낼 수 있다.

우리가 아는 데스크탑에 끼우는 16GB 램을 SRAM으로 구현하려면 같은 용량을 위해 약 10배가량 더 큰 칩 면적이 필요하다.

비용은 수십배 이상 증가하게 된다.(데스크탑 메모리 16기가의 평균소비가는 5만원이다.)

전력 소모량도 매우 커진다.

하드웨어적으로 SRAM의 하나의 셀에 대한 구현은 DRAM에 비해 크기가 크고 더 많은 트랜지스터를 필요로 한다.

6개의 트랜지스터가 잘 동작하기 위해 항상 전력 공급이 필요하고 SRAM은 그 결과 항상 전체적으로 활성화된 상태라고 볼 수 있다.

반면 DRAM은 대부분의 시간 동안의 대부분의 영역에서 정지된 상태를 가져간다. 그렇기에 전력 소비가 적다.

즉 속도적인 측면에서 매우 우수한 SRAM은 매우 많은 부분에서 DRAM을 이길 수 없다.

그렇기에 DRAM을 우리가 아는 메모리로 활용하며, SRAM을 CPU에 두어 캐시메모리로 소용량 사용하여 각각의 장단점을 최대한 활용하는 것이 현대의 컴퓨터 시스템이다.

### SDRAM(Synchronous DRAM)

"S"가 들어가지만 `Synchronous`에서 알 수 있듯 SRAM과는 명백히 다르다.

DRAM의 발전된 형태라고 생각하는 것이 맞다.

클럭 신호와 동기화된 DRAM이다.

즉 CPU와 같은 클럭 체계를 공유한다.

### DDR SDRAM(Double Data Rate SDRAM)

현재 우리가 대중적으로 사용하는 데스크톱에서 사용하는 DDR 메모리가 이것이다.

발전된 형태의 SDRAM이며 `대역폭`을 넓혀 속도를 빠르게 만든 SDRAM이다.

DDR기술은 **기존 SDR SDRAM(Single Data Rate)**의 속도를 두 배로 개선한 메모리 기술이다.

기존의 Single Data Rate의 방식은 클럭의 상승 에지에서만 데이터를 보냈는데, `Double Data Rate`는 클럭의 상승과 하강에지에서 모두 데이터를 보내므로 같은 클럭에서 두 배의 데이터 전송률을 보일 수 있는 것이다.

#### 왜 Double Data Rate를 처음부터 채택하지 않았는가?

초기에는 SDRAM도 이미 획기적인 기술이었으며 Double Data Rate는 회로 타이밍을 맞추기 훨씬 어렵다는 기술적 문제가 있었다. 여러 극복할 문제가 있었으며 이것이 현대에서는 안정적으로 해결되어 가능한 기술이 된 것이다.

#### 상상력을 동원하면 한 클럭당 2개의 데이터만 보내는 것보다 4개의 데이터를 보내는 것도 가능하지 않나? QDR이라 이름을 붙일 수도 있을 것 같다.

사실 QDR(클럭당 4번 전송) 기술도 이미 존재한다.

GPU 메모리에서 GDDR6X와 같은 기술로 적용되고 있고 QDR SRAM과 같은 기술도 존재한다.

하지만 일반적으로 사용하는 메모리에서 이를 적용하기 위해서는 발열 관리, 타이밍 정렬, 복잡도 증가와 같은 이전에 싱글 기반에서 DDR로의 발전이 어려웠던 이유와 비슷하게 어려운 것이 된다.

전송률에 미치는 것은 데이터양/시간 이다.

이때 데이터를 늘리면 전송률은 높아진다. 

데이터양을 늘리는 방법으로 DDR은 같은 시간 대비 두 배의 데이터를 보내는 방법을 택했다.

여전히 DDR는 클럭신호에 의지한다. 클럭 신호를 극한으로까지 활용하는 것이 DDR이며 더 극한으로 사용해서 QDR도 가능하지 않나?라는 상상은 충분히 합리적이지만

최근 연구되고 상용화되는 HBM과 같은 기술은 더 이상 한정적인 신호 주기 안에서 더 많은 데이터를 전송하는 것으로 대역폭을 넓히는 것이 아닌 병렬적인 데이터 전송 방식을 택해 더 많은 도로를 깔아 대역폭을 늘리는 방식을 채택한 것이다.

메모리를 수직으로 쌓고 메모리에 연결된 버스를 병렬적으로 늘려 한번에 보내는 데이터를 많게 한다면 전송률이 올라가는 것과 마찬가지의 효과를 얻게 된다.

##### 그럼 일반 DRAM의 발전도 버스를 늘려 한번에 보내는 데이터가 많도록 시도할 수 있지 않았을까?

첫번째로 메인보드의 물리적 제약이 존재한다.

버스 폭을 늘리게 되면 CPU - RAM 간의 배선 수가 폭증하게 된다. (메모리 전송량 64 bit가 현실적인 최적점인 이유)

신호 간섭 및 크기 문제, 비용 문제로 메인보드 설계 난이도가 매우 증가한다.

또한 병렬 버스를 늘릴수록 동작 시마다 더 많은 신호선이 활성화되어야 하고 이는 곧 전기를 필요로 하고 이는 곧 발열로 이어진다.

HBM 기술은 이런 문제가 크지 않도록 병렬화에 성공할 수 있는 이유는 우선 CPU와의 거리가 매우 짧아 버스가 짧아지는 구조도 같이 채택했기 때문이다.

#### DDR 시리즈의 발전은 어떻게 설명이 가능한가?

DDR이란 기술은 여전히 하나의 클럭에 데이터 두 개를 보내는 개념이다.

어떻게 DDR은 전송률을 버전마다 개선해나갔을까?

메모리 또한 버스로 하여금 메모리의 데이터를 CPU로 보내는 것과 메모리 안에서 데이터를 읽는 것 간의 속도 차이가 존재한다.

버스를 통해 나가고 들어오는 것은 굉장히 빠르나, 메모리 내부의 데이터를 찾아 읽는 것은 버스이동보다 느리다.

이러한 속도 병목이 존재하는 지점을 최적화해나가는 것이 DDR 시리즈의 발전이다.

메모리 컨트롤러는 CPU가 요청한 데이터의 주변부 데이터까지 모두 버스로 통하기전의 버퍼에 저장해놓고 매우 빠르게 내보낸다. 이 경우 버스를 통해 나가고 들어오는 속도에 근접하게 되는 것이다.

# 메모리 내 주소체계

메모리 내의 주소체계는 두 가지로 다음과 같다.
- 논리 주소
- 물리 주소

**CPU와 실행 중인 프로그램은 현재 메모리 몇 번지에 다른 프로그램이 어떻게 무엇이 저장되어 있는지 다 알고 있을까?**

그렇지 않다.

메모리에 저장된 값들은 시시각각 변하게 된다.

새롭게 실행되는 프로그램이 메모리에 적재되거나, 어떤 프로그램은 삭제되고, 같은 프로그램을 다시 한번 실행해더라도 그 프로그램의 메모리상 주소는 달라질 수 있다.

물리 주소란 메모리 입장에서 바라본 주소, 즉 정보가 실제로 저장된 하드웨어상 주소이다.

논리 주소란 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주소이다.

만약 프로그램A의 논리 주소가 0~i번지까지 생성될 수 있고 동시에 프로그램B에 대해 논리 주소가 0~k번지까지 생성될 수 있다. 그러나 프로그램A,B의 실제 물리주소들은 각각 a~b번지, u~q번지와 같이 존재해야한다. 즉 물리주소상으로는 겹칠 수 없다.

프로그램A, B의 0번지에 데이터 입출력을 동시에 진행한다면, 둘 다 논리주소 0번지에 대한 동작을 수행해야한다. 만약 논리주소를 물리주소로 변환하지 않는다면 메모리 입장에서는 0번지는 하나밖에 없는데 무슨소리야와 같은 문제가 생길 것이다.

## 논리주소 -> 물리 주소로의 변환

논리 주소에서 물리 주소로의 변환은 `MMU(메모리 관리 장치)`라는 하드웨어에 의해 변환된다.

CPU가 이해하고 실행하는 주소는 `논리 주소`이다. 만약 CPU가 명령어를 처리하는 과정에서 메모리의 논리 주소로 하여금 데이터를 레지스터로 끌고와야한다고 생각해보자.

이때 명령어의 논리 주소를 MMU에서 물리 주소로 바꾸어 메모리에서 데이터를 인출한다.

MMU는 논리 주소와 `베이스 레지스터 값`을 더하여 논리 주소를 물리 주소로 변환한다.

베이스 레지스터의 값은 OS가 프로그램을 실행할 때, 즉 프로세스가 메모리에 적재될 때 메모리 물리 주소의 위치를 결정하기 위한 값이다.

베이스 레지스터 값은 프로세스의 메모리상 물리 주소의 시작점이라고 볼 수 있다.

## 메모리 보호

만약 베이스 레지스터 값이 1000이면서 최대 논리 주소가 50인 프로세스에 대해서 갑자기 논리주소 100번지에 대한 수정 명령어가 실행된다고 한다면 이는 다른 프로세스에 영향을 줄 것이다.

이러한 오류를 막기 위해, 한계 레지스터에 논리 주소의 최댓값을 저장하여 프로세스의 물리 주소 범위를 계산할 수 있어, 이를 통해 오류를 방지할 수 있다.

