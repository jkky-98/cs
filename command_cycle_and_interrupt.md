# 명령어 사이클과 인터럽트

CPU는 메모리에 담긴 명령어를 **정해진 흐름**대로 처리한다. 

CPU는 명령어를 일정한 주기에 맞추어 실행하며 이 주기를 **명령어 사이클**이라고 한다.

정해진 흐름대로 명령어를 처리하는 CPU에게 **인터럽트**가 들어오게 되면 흐름이 끊어진다.

---

## 명령어 사이클

**명령어 사이클**은 아래의 **3가지 사이클**로 분류되며 **인출 - 필요시 간접 - 실행 사이클**을 반복적으로 처리하며

CPU가 작업을 수행한다. 이 흐름이 위에서 말한 **정해진 흐름**이다.

### 인출 사이클

- CPU가 메모리로부터 명령어를 가져오는 작업을 **인출**이라고 하며 이 또한 주기에 맞추어 진행된다.
- 이 주기를 **인출 사이클**이라고 한다.

### 실행 사이클

- 가져왔다면 **실행** 해야한다.
- 실행또한 주기가 존재하며 이 주기를 **실행 사이클**이라고 한다.
- 인출 사이클과 실행 사이클에 맞추어 **인출 - 실행 - 인출 - 실행....** 으로 메모리의 명령어를 실행시킨다.

### 간접 사이클

- 명령어의 오퍼랜드에는 **메모리의 주소가 담겨있을 수 있다**. 
- 이는 인출 이후 곧바로 실행되는 것이 아닌 실행을 위해 다시 메모리에 접근해야하는 경우이며
- **인출 - 실행**이 곧바로 불가능하여 **간접 사이클**을 만들어내어 간접 사이클이 끝나고 실행 사이클이 진행된다.

---

## 인터럽트

CPU가 정해진 흐름대로 작업을 수행중인데, 이 흐름을 끊는 CPU로의 신호가 **인터럽트**이다.

> **어떨 때 끊어야 할까?**  
> 새로운 이벤트가 발생하고 그 이벤트가 CPU가 얼른 처리해야할 경우에 **인터럽트**가 발생한다.

**인터럽트는 아래 두 가지 방식으로 나뉜다.**

---

### 동기 인터럽트

- 동기 인터럽트는 CPU가 예기치 못한 상황(예외)을 접했을 때 발생한다.

### 비동기 인터럽트

- 주로 입출력 장치에 의해 발생한다. 즉 다른 하드웨어에 의한 인터럽트이다.
- 예시: 사람이 키보드를 친다면 이는 곧바로 CPU에 **비동기 인터럽트 신호**가 전해지며 키보드 입력에 대한 처리를 CPU가 곧바로 처리하게 된다.

> 그렇기에 비동기 인터럽트는 다른 하드웨어의 알림의 개념과 비슷하다.

---

## 왜 이러한 방식을 채택했을까? 

- 이러한 설계는 CPU가 입출력 작업 도중에도 효율적인 명령어를 처리하기 위함이다.
- 인터럽트가 존재하지 않는다면, CPU는 다른 하드웨어에게 주기적으로 입력이 들어왔는지 확인해야한다.

> 초당 수억개 이상의 제어 신호를 발생시킬 수 있는 CPU에 대해 우리가 아무리 키보드를 빠르게 친다더라도 키보드의 입력을 처리하기 위한 CPU의 리소스는 굉장히 적다.

- 그렇기에 **평소에 해야하는 CPU의 일을 수행하다가 키보드나 마우스 입력과 같은 일을 아주 잠깐 수행하는 것이다.**

---

### 📌 직관적 비유

> 처음 이러한 개념을 숙지하면  
> "키보드 입력 한번에 대해 인터럽트 -> 키보드 입력 처리 -> 다시 원상복구"  
> 와 같은 시나리오에 대해 굉장히 비용소모적으로 보이지만,  
> 실제 CPU 입장에서는 우리가 열심히 뇌를 써서 공부하는 와중에 **숨을 쉬는 것에 뇌를 쓰는 것이 부담이 없듯** 비슷한 느낌이다.

---

## 입출력 장치 CPU 처리 과정 상세

1. 입출력장치는 CPU에 **인터럽트 요청신호**를 보낸다.
2. 항상 CPU는 **실행 사이클이 끝나고 다음 명령어 인출 전** 인터럽트 여부를 확인한다.
3. CPU가 인터럽트 요청을 확인했따면 **인터럽트 플래그**를 통해 자신이 현재 인터럽트를 받아들일 수 있는지 확인한다.
    - 플래그 레지스터의 인터럽트 플래그를 확인해서 인터럽트 여부를 확인한다.
    - 그렇다면 인터럽트 플래그가 닫혀있다면 모든 인터럽트가 막히는가?  
      → **그렇지는 않다.** (긴급한 상황의 인터럽트(non maskable interrupt)는 막을 수 없다.)

4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업(정해진 흐름)을 백업한다.
    - 프로그램 카운터 및 레지스터들에는 정해진 흐름대로 수행하던 작업에 관련한 데이터들이 담겨있다.
    - 인터럽트 실행이전 이 값들을 **메모리 스택영역에 백업**해둔 뒤 인터럽트 서비스 루틴이 끝나면 메모리에서 다시 데이터를 가져온다.

5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴(프로그램)**을 실행한다.
    - ISR은 OS 커널에 내장되어 있고, 메모리에 존재한다.
    - 각 ISR은 고유 번호로 식별되며, **IDT(인터럽트 디스크립터 테이블)**를 통해 해당 주소를 찾는다.

6. 인터럽트 서비스 루틴의 실행이 끝나면 **백업해둔 작업을 복구하여 실행을 재개한다.**

---

## 정리

> 정리하면 명령어 사이클은  
> 기본적으로 **인출 및 실행 사이클**로  
> **간접 사이클과 인터럽트 사이클**이 조건적으로 끼어 **순환하는 구조**가 된다.