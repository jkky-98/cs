# CPU 스케줄링

`CPU 스케줄링`이란 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 말한다.

**많은 양의 프로세스에 대해 가장 공정하게 `CPU 자원`을 배분하는 방법이 있을까?**

프로세스 CPU자원 할당에 관한 스케줄링은 프로세스의 우선순위에 따라 달라질 수 있다.

운영체제 내부에서 스스로 이를 정할 수도 있고 개발자가 우선순위를 높여 유도할 수도 있다.

```java
Thread t1 = new Thread(() -> {
    // 작업 내용
});
t1.setPriority(Thread.MAX_PRIORITY); // 우선순위 10
```

이러한 우선순위 설정을 통해 `처리 우선순위`를 유도할 수 있지만 운영체제의 스케줄러에 의해 무시될 수도 있다.

즉, 직접 개발자가 설정하는 우선순위는 `힌트`이지 `보장`이 아니다.

## 입출력 집중 프로세스(I/O Bound Process) vs CPU 집중 프로세스(CPU Bound Process)

보통적으로 `입출력 집중 프로세스(I/O Bound Process)`의 우선순위는 `CPU 집중 프로세스(CPU Bound Process)`보다 높다.

입출력 집중 프로세스는 CPU 집중 프로세스보다 입출력 처리를 기다리며 대기 상태(CPU를 쓰지 않고 기다리는 중인 상태)에 더 자주 있게 된다.

우선 프로세스든 쓰레드든 서로가 교체되는 컨텍스트 스위칭은 아주 짧은 시간이라는 것을 다시 인지하자.

스케줄링 큐에 입출력 집중 프로세스와 CPU 집중 프로세스의 쓰레드가 있을 때 

**어차피 입출력 집중 프로세스의 작업은 처리중에 입출력 요청을 받아 대기 상태로 들어갈 확률이 높다.**

**그렇기에 어차피 빠르게 대기 상태에 들어갈 작업을 빠르게 처리하고 CPU 집중 프로세스를 처리하는 것이다.**

# 스레딩 모델

`스레딩 모델`은 운영체제와 프로세스가 어떻게 사용자 스레드와 커널 스레드를 연결하고 스케줄링 하는지를 설명하는 구조이다.

## 사용자 스레드(Green Thread) 와 커널 스레드(Kernel Thread)

`사용자 스레드(Green Thread)`는 커널과 무관하게 사용자 영역에서 구현된 가짜 스레드이다.

운영체제가 아닌 JVM이나 goroutine과 같은 운영체제가 아닌 프로그램이 가짜 스레드들을 스케줄링하여 운영한다는 것이다.

이런 스레드를 여러 개 생성하고 스케줄링하여 사용한다고 해보자.

실제로 멀티 스레드와 같이 병렬적으로 돌아가는 것처럼 보이지만 사실은 운영체제 입장에서는 하나의 스레드일 뿐이다.

초창기 JVM또한 이러한 방식을 채택했지만 현재 JVM은 커널 스레드로 실제 병렬처리가 가능한 구조를 가진다.

### 이해를 위한 다이어그램

#### 커널 스레드 기반 구조 1:1 구조

```
   [커널 스레드 기반 구조 (1:1)]
   ┌─────────────┐
   │  Java Thread 1  ─────────────┐
   └─────────────┘                │
                                  ▼
                            ┌────────────┐
                            │ Kernel Thread 1 │
                            └────────────┘

   ┌─────────────┐
   │  Java Thread 2  ─────────────┐
   └─────────────┘                ▼
                            ┌────────────┐
                            │ Kernel Thread 2 │
                            └────────────┘

```

#### 사용자 스레드 기반 구조 (M:1, Green Thread)

```
   [사용자 스레드 기반 구조 (M:1, Green Thread)]
   ┌─────────────┐
   │ Green Thread 1 │
   ├─────────────┤     ← 사용자 수준에서 스케줄링
   │ Green Thread 2 │
   ├─────────────┤
   │ Green Thread 3 │
   └─────────────┘
           │
           ▼
   ┌───────────────────┐
   │  Kernel Thread (1개) │
   └───────────────────┘

```
### 언어 별 스레딩 모델

Java 애플리케이션 (HotSpot JVM), CPython
→ Thread는 대부분 커널 스레드와 1:1
→ 1:1 모델

Go 언어 애플리케이션
→ 고루틴 수천 개를 실행하지만, 커널 스레드는 수십 개
→ M:N 모델

옛날 JVM (Green Threads 사용 시절), Python greenlet, gevent
→ 사용자 수준 스레드만 존재
→ M:1 모델

# CPU 스케줄링 큐

CPU 스케줄링 큐는 커널 스레드에 대해서만 해당하는 개념이다.

스레드 단위로 큐에 작업이 존재하며 OS 스케줄러에 의해 스케줄링 된다.

위 스레딩 모델을 이해했다면 `사용자 스케줄링 큐`는 각 프로그램이 직접 구성한 스케줄링 큐인 것을 알 수 있을 것이다.

## M:N 모델에서 스케줄링 큐 구조

```
[사용자 스케줄링 큐] ← 사용자 스레드들이 대기
         │
         ▼
[커널 스케줄링 큐] ← 운영체제가 관리하는 커널 스레드들이 대기
         │
         ▼
       CPU 실행

```
사용자 스레드가 여러 개 있어도 OS 입장에서는 그들을 매핑한 소수의 커널 스레드만 스케줄링 큐에 존재한다.

사용자 스케줄러가 더 자주, 가볍게 사용자 스레드끼리 전환하며 OS 스케줄러는 커널 스레드 단위로 상대적으로 무겁게 CPU 스케줄링을 한다.

## 멀티코어 시스템에서의 관점

운영체제는 스레드에 CPU자원을 할당한다.

멀티 코어 시스템에서는 여러 스레드에 동시에 CPU 자원을 할당할 수 있다.

실제 기계적인 병렬처리가 가능해지는 것이다.

그렇다면 위 스레딩 모델을 이해하고 JVM 기반 멀티 스레드에 의한 처리가 빠를지

Python 기반 GreenThread에 의한 사용자 멀티 스레드에 의한 처리가 빠를지 판단할 수 있다.

## JVM의 사용자 스레드(Green Thread) 사용 시절

1990년대 후반~2000년대 초반 초창기 JVM은 Green Thread(사용자 스레드) 방식을 썼다.

당시 대부분 단일 코어 CPU였고, OS 스레드 관리가 무겁거나 지원이 덜 성숙했기 때문이다.

JVM이 직접 스레드 스케줄링을 하면서 경량화된 문맥 전환을 구현했었다.

OS 커널 입장에선 하나의 커널 스레드만 존재하니 멀티코어 병렬 처리도 불가능했다.

CPU가 멀티코어로 발전하면서 **진짜 병렬 처리(동시 다발적 실행)**가 가능해졌.

Green Thread 모델은 커널에서 인식하는 스레드가 하나뿐이므로 멀티코어 활용 불가라는 한계가 컸.

반면, 커널 스레드 기반 모델은 OS가 각각의 스레드를 병렬로 실행할 수 있다.

이에 따라 Sun Microsystems는 HotSpot JVM부터 1:1 커널 스레드 모델로 전환한 것이다.

## 준비 큐와 대기 큐

CPU 스케줄링 큐는 `준비 큐`와 `대기 큐`로 나눌 수 있다.

준비 큐는 CPU 자원을 받기 위해 쓰레드가 대기하는 큐이고

대기 큐는 입출력 장치 처리에 의해 대기중인 쓰레드가 존재하는 큐이다.

대키 큐에 존재하는 스레드는 입출력 완료 인터럽트에 의해 다시 준비 큐로 가서 CPU 자원 할당을 기다린다.

이러한 대기 큐는 입출력 장치 별로(프린터 대기 큐, 하드 디스크 대기 큐...) 존재한다.

# 선점형 스케줄링(현대의 OS는 이 방식을 사용) 과 비선점형 스케줄링

CPU 자원을 받아 실행중인 프로세스(A)가 있고, 준비 상태인 프로세스(B)가 있다.

B가 "너무 급한데 CPU를 잠시 써도 될까요" 요청하는 상황이 존재한다면

- 1.A가 할당 받은 자원을 빼앗아 B에 할당해줄 수 있을 것이다.
- 2.아무리 급하더라도 A를 기다린다.

와 같은 두가지 방법이 존재한다.

선점형 스케줄링은 1의 방식을 뜻하며 비선점형 스케줄링은 2의 방식을 뜻한다.

우리가 이때까지 공부한,

운영체제의 스케줄링에 의해 프로세스A에 타이머 인터럽트를 걸어 다른 프로세스B로의 전환하는 이러한 방식이

`선점형 스케줄링`의 예시이다.

비선점형 스케줄링은 타이머 인터럽트가 아니라 A의 작업이 끝날때 까지 그냥 기다려야한다는 것이다.

당연히 선점형의 경우 여러가지를 골고루 짧게 짧게 실행할 수 있는 장점이 있지만 단점으로는 교체 비용이 있다는 것이다. 반면 비 선점형은 그 반대로 골고루 실행할 수 없지만 교체 비용없이 작업을 처리할 수 있다는 것이다.




