# 보조 기억 장치

## 하드 디스크

자기적인 방식으로 데이터 저장

![image](https://github.com/user-attachments/assets/47633fed-8096-4ff4-8631-fbed253a2441)

CD처럼 생긴 `플래터`에 데이터가 존재하며 플래터는 여러 겹으로 구성된다.

이 플래터를 `스핀들 모터`가 RPM단위로 회전시킨다.

플래터에 데이터를 읽고 쓰는 수단으로 존재하는 것이 `헤드`이다.

![image](https://github.com/user-attachments/assets/a93b0ca4-0001-4e76-924a-d609334c66d6)

그리고 이 플래터의 트랙과 섹터 단위로 데이터가 저장된다.

여러겹의 플래터에 대해 같은 트랙들에 대하여 `실린더`를 이룬다. (보통 연속된 정보는 한 실린더에 기록된다. -> 헤드가 움직일 필요가 없어 이 방식이 효율적이다.)

### 하드 디스크가 저장된 데이터에 접근하는 시간

하드 디스크에 저장된 데이터를 꺼내는 시간은 탐색 시간, 회전 지연, 전송 시간을 계산해서 구할 수 있다.

탐색 시간은 헤드가 움직이는 시간이며, 회전 지연은 이 헤드에 플래터를 맞추기 위해 플래터를 회전할 때 걸리는 시간이며 전송 시간은 하드 디스크와 컴퓨터 간의 데이터를 전송하는 시간이다.

하드 디스크의 데이터를 꺼내는 시간은 캐시 메모리나 메모리에 비해 매우 큰 시간 비용이 소모된다.

L1캐시를 읽는 시간이 대략 0.5ns, 메모리 참조시간이 대략 100ns인 것에 비해 하드 디스크 참조 시간은 `10,000,000ns`에 해당한다.

## 플래시 메모리

SSD, USB가 이에 해당한다.

자기적인 방식의 하드디스크와 달리 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치이다.

이때 `SSD`의 경우 `ROM(주기억장치)`으로 사용된다.

플래시 메모리는 들어봤을 법한 NAND 플래시 메모리와 아마 생소할 NOR 플래시 메모리로 나뉜다.

우리가 사용하는 SSD의 경우 `NAND 플래시 메모리`이며 이 두 플래시 메모리의 차이점을 아는 것은 프로그래머가 알아야할 영역을 넘기 때문에 이해할 필요는 없다고 생각한다.(낸드 = SSD라고 생각하자.)

플래시 메모리는 `Cell`이라고 하는 데이터 저장 단위를 사용하며 이 셀이 모여 수 GB, TB의 SSD가 된다.

한 셀에 1,2,3,4 비트를 저장할 수 있는 플래시 메모리의 타입으로 SLC, MLC, TLC, QLC로 나눌 수 있다.

우리가 시중에서 사서 데스크탑에서 쓰는 흔한 SSD는 TLC 이다.

한 셀에 여러 비트를 저장할 수 있다는 점에서 높은 비트 수를 한 셀에 저장하는 타입이 좋지 않나 싶지만 오히려 거꾸로이다.

| 종류      | 풀네임               | 비트/셀 | 속도       | 수명      | 가격       | 현재 사용처                          |
| ------- | ----------------- | ---- | -------- | ------- | -------- | ------------------------------- |
| **SLC** | Single-Level Cell | 1bit | 🔥 가장 빠름 | 🔋 가장 김 | 💰 매우 비쌈 | 고급 산업용, 서버, 일부 캐시 용도로 극히 제한적 사용 |
| **MLC** | Multi-Level Cell  | 2bit | 빠름       | 김       | 비쌈       | 고급 SSD (거의 단종 추세)               |
| **TLC** | Triple-Level Cell | 3bit | 보통       | 보통      | 저렴       | ✅ **대다수 소비자 SSD**               |
| **QLC** | Quad-Level Cell   | 4bit | 느림       | 짧음      | 가장 저렴    | 용량 중시 보급형 SSD, 아카이브용            |

하나의 셀에 많은 비트를 구분해야한다면 전압을 더욱 정교하게 구분해서 조작해주어야 하기 때문에 쓰기 속도가 느려진다. 

SLC의 경우 1비트(0 or 1)만을 판단하면 되기에 정교하게 전기를 조작해줄 필요가 없지만, 비트가 늘어날 수록 전압차를 매우 잘 계산해야한다.

그런데 셀 내부 절연체는 쓰면 쓸수록 마모된다는 특징을 가진다.

0과 1을 판단하는데에는 이것이 마모된다 하더라도 둘 중 하나만을 구분하면 되는 것이니 큰 문제가 없지만 비트가 늘어나면 값을 잘못 판단하게 될 수 있다.

그렇기에 수명적인 관점에서도 한 셀에 들어가는 비트가 작아질 수록 수명이 길다.

한 셀에 비트를 줄이게 될 수록 구현해야하는 용량이 동일하다면 셀의 수가 늘어나기에 가격적으로도 당연히 비트 수가 작아질수록 비싸진다.

셀이 마모된다면 SSD의 자체적인 방식으로 망가진 셀의 정보를 다른 셀로 옮긴다.

### 플래시 메모리 저장단위

셀 -> 페이지(셀의 모임) -> 블록(페이지의 모임) -> 플레인(블록의 모임) -> 다이(플레인의 모임)

![image](https://github.com/user-attachments/assets/01ca891a-7314-4b32-8ff0-db850138154a)

### 동작 단위

읽기와 쓰기는 페이지 단위로, 삭제는 블록 단위로 이루어진다.

삭제는 블록(수백 KB수 MB) 단위로만 가능한 이유는, 플래시 메모리의 셀 구조상 전하를 주입(쓰기)하거나 측정(읽기)은 미세하게 제어할 수 있지만, 

전하를 완전히 제거(삭제)하려면 높은 전압을 걸어야 하며 이는 안정성과 전기적 제약으로 인해 블록 전체에만 적용할 수 있기 때문이다

### 페이지의 상태

- Free 상태 : 어떠한 데이터도 저장하고 있지 않은 상태
- Valid 상태 : 이미 데이터 저장하고 있는 상태
- Invalid 상태 : 쓰레기 값을 저장하고 있는 상태

### 플래시 메모리의 가비지 컬렉션

플래시 메모리는 블록 단위로만 데이터를 삭제할 수 있기에

(동일 블록 가정) 만약 어떤 페이지의 값을 수정하려고 한다면 그 페이지는 죽은 페이지로 두고 빈 페이지에 새로운 값을 넣는다.

이런 방식을 계속 쓰다보면 `죽은 페이지`가 매우 많아져 유효한 페이지 공간이 계속해서 부족해져갈 것이다.

이를 방지하기 위해 유효한 페이지들만으로 새로운 블록을 생성하고 기존의 블록을 삭제하여 공간 낭비를 방지한다.

# RAID(Redundant Array of Independent Disks)

1TB 하드디스크 4개 vs 4TB 하드디스크 1개 어떤 구성이 성능과 안전성을 높을까?

1TB 하드디스크 4개로 `RAID` 기술을 사용하여 구성하면 4TB 하드디스크보다 성능적으로, 안정성면으로 능가할 수 있다.

## RAID 레벨

RAID 레벨이란 RAID를 구성하는 기술로써 RAID 0, 1, 2, ... ,6 그로부터 파생된 RAID 10, 50, ... 등이 존재한다. 

범용적으로 사용되는 0, 1, 4, 5, 6에 대해 알아보자.

### RAID 0 

`RAID 0`은 데이터를 단순히 나누어서 저장하는 구성 방식이다.

`스트라이핑(Striping)` 방식으로 저장하는데 하나의 파일에 대해 여러 개의 디스크에 블록 단위로 쪼개어 병렬로 기록하는 것이다.

이 방식은 안정성은 좋지 못하지만 속도적으로는 매우 우수한 방식이다.

파일1(100mb)을 파일1-1(25mb), 1-2(25mb), 1-3(25mb), 1-4(25mb)로 쪼개어 각각 쓰기와 읽기를 수행한다고 해보자.

만약 하나의 하드디스크가 25mb당 쓰기 속도가 0.1s라면 쪼개어 쓰기를 진행할 때 0.1만에 100mb에 해당하는 파일을 쓸 수 있다.

읽을 때도 마찬가지이다. 100mb를 하나의 하드로만 읽는 것보다 쪼갠 것을 동시에 읽어 합친다면 훨씬 빠른 속도로 읽을 수 있다.

**문제는 하나의 하드라도 고장난다면 파일1은 절대 읽어질 수 없게 된다.**

### RAID 1

`RAID 1`은 데이터를 완전히 동일하게 두 개 이상의 디스크에 복제해서 저장하는 것이다.(미러링 방식)

마치 백업 DB를 구성하는 것과 같은데 문제는 쓰기시 항상 복제 디스크에도 쓰기를 수행해야하기 때문에 쓰기 속도가 개선되지 않는다.

100mb 파일을 쓴다면 두 개의 하드가 존재한다고 가정하고, 하드1에도 하드2에도 100mb를 작성하고 읽을 때는 둘 중 하나의 하드에서 읽게 된다.

즉 백업 디스크가 구성되는 것이라 사실상 두 하드디스크를 쓰더라도 사실상 하나의 디스크 용량만 실제 사용이 가능한 것 처럼 보인다.

하지만 하나의 하드가 손상되더라도 백업이 존재하기에 안정성면으로는 RAID 0와 달리 매우 우수하다.

그렇다 RAID 0 은 속도에만, RAID 1은 안정성 측면만 매우 극단적으로 추구하게 된다.

### RAID 4

RAID 4의 경우 최소 3개의 저장 장치가 필요하며

하나의 디스크만 복구를 위한 `패리티 정보`를 가진 디스크로 두고

나머지 디스크는 RAID 0 방식과 동일하게 구성하는 것이다.

패리티 디스크는 XOR 역연산으로 하여금 복구가 가능하도록 하는 역할이다.


| 블록 | D1 | D2 | D3 | D4 | P (패리티 디스크) |
| -- | -- | -- | -- | -- | ----------- |
| 1  | A1 | A2 | A3 | A4 | A1⊕A2⊕A3⊕A4 |
| 2  | B1 | B2 | B3 | B4 | B1⊕B2⊕B3⊕B4 |
| 3  | C1 | C2 | C3 | C4 | C1⊕C2⊕C3⊕C4 |

만약 D1이 고장났다면 D2, D3, D4 + 패리티 디스크로 D1을 복구하여 정상 사용이 가능하다.

하지만 D1, D2가 고장났다면?

**복구 불가능**하다.

결국 RAID 4는 하나의 디스크 고장에 대해서만 안전성을 보장한다.

또 속도적으로 병목 문제가 존재하는데, 위 예시에서 D1 ~ D4의 쓰기 작업에서 패리티 디스크는 이에 종속적이다.

즉 `P = D1 ⊕ D2 ⊕ D3 ⊕ D4`의 계산은 D1이 수정되면 P는 수정되어야하고 D2가 수정되어도 P는 수정되어야 하기에 쓰기 작업에 대해 항상 P가 갱신되어야 하는 문제가 있다.

동시에 D1은 수정작업을 20, D2는 수정작업을 15 진행한다면 P는 그 둘을 더한 35만큼 작업해야 한다.

그렇기에 D1이 다 끝나도, D2가 다 끝나도 P는 바쁘다. 이런 관점에서 병목이 발생한다.

### RAID 5

RAID 4의 병목 문제를 개선하기 위해 RAID 5가 나왔으며, RAID 5의 단점 극복때문에 RAID 4는 사장되었다.

RAID 4에서는 패리티 디스크를 구성했지만 RAID 5는 모든 디스크가 패리티를 가질 수 있다. 아래의 예시를 보자.

| 블록 | D1     | D2     | D3     | D4     | D5 (패리티) |
| -- | ------ | ------ | ------ | ------ | -------- |
| 1  | A1     | A2     | A3     | A4     | **P1**   |
| 2  | B1     | B2     | B3     | **P2** | B4       |
| 3  | C1     | C2     | **P3** | C3     | C4       |
| 4  | D1     | **P4** | D2     | D3     | D4       |
| 5  | **P5** | E1     | E2     | E3     | E4       |

패리티가 여러 디스크에 분산되어 있기 때문에,

여러 쓰기 작업이 동시에 발생할 때도 각 디스크에 고르게 부담을 분산시켜 쓰기 병목이 발생하지 않는다.

### RAID 6

RAID 6는 RAID 5의 특징을 가지면서도 RAID 4가 가진 또 하나의 단점, 두 개이상 디스크 고장시 데이터 복구에 대한 문제를 다룬 레벨이라고 볼 수 있다.

RAID 4나 5는 블록 단위에 대해 하나의 디스크만 패리티를 가지지만 RAID 6는 두 개의 디스크가 패리티를 가진다.

| 블록 | D1     | D2     | D3     | D4     | D5     | D6     |
| -- | ------ | ------ | ------ | ------ | ------ | ------ |
| 1  | A1     | A2     | A3     | A4     | **P1** | **P2** |
| 2  | B1     | B2     | B3     | **P1** | B4     | **P2** |
| 3  | C1     | C2     | **P1** | C3     | **P2** | C4     |
| 4  | D1     | **P1** | D2     | D3     | **P2** | D4     |
| 5  | **P1** | E1     | E2     | E3     | **P2** | E4     |

이 경우 한 개의 고장이 아닌 두 개의 고장까지 버틸 수 있으나

이 역시 다시금 세 개 이상의 고장에는 대응할 수 없다.

