# 보조 기억 장치

## 하드 디스크

자기적인 방식으로 데이터 저장

![image](https://github.com/user-attachments/assets/47633fed-8096-4ff4-8631-fbed253a2441)

CD처럼 생긴 `플래터`에 데이터가 존재하며 플래터는 여러 겹으로 구성된다.

이 플래터를 `스핀들 모터`가 RPM단위로 회전시킨다.

플래터에 데이터를 읽고 쓰는 수단으로 존재하는 것이 `헤드`이다.

![image](https://github.com/user-attachments/assets/a93b0ca4-0001-4e76-924a-d609334c66d6)

그리고 이 플래터의 트랙과 섹터 단위로 데이터가 저장된다.

여러겹의 플래터에 대해 같은 트랙들에 대하여 `실린더`를 이룬다. (보통 연속된 정보는 한 실린더에 기록된다. -> 헤드가 움직일 필요가 없어 이 방식이 효율적이다.)

### 하드 디스크가 저장된 데이터에 접근하는 시간

하드 디스크에 저장된 데이터를 꺼내는 시간은 탐색 시간, 회전 지연, 전송 시간을 계산해서 구할 수 있다.

탐색 시간은 헤드가 움직이는 시간이며, 회전 지연은 이 헤드에 플래터를 맞추기 위해 플래터를 회전할 때 걸리는 시간이며 전송 시간은 하드 디스크와 컴퓨터 간의 데이터를 전송하는 시간이다.

하드 디스크의 데이터를 꺼내는 시간은 캐시 메모리나 메모리에 비해 매우 큰 시간 비용이 소모된다.

L1캐시를 읽는 시간이 대략 0.5ns, 메모리 참조시간이 대략 100ns인 것에 비해 하드 디스크 참조 시간은 `10,000,000ns`에 해당한다.

## 플래시 메모리

SSD, USB가 이에 해당한다.

자기적인 방식의 하드디스크와 달리 전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치이다.

이때 `SSD`의 경우 `ROM(주기억장치)`으로 사용된다.

플래시 메모리는 들어봤을 법한 NAND 플래시 메모리와 아마 생소할 NOR 플래시 메모리로 나뉜다.

우리가 사용하는 SSD의 경우 `NAND 플래시 메모리`이며 이 두 플래시 메모리의 차이점을 아는 것은 프로그래머가 알아야할 영역을 넘기 때문에 이해할 필요는 없다고 생각한다.(낸드 = SSD라고 생각하자.)

플래시 메모리는 `Cell`이라고 하는 데이터 저장 단위를 사용하며 이 셀이 모여 수 GB, TB의 SSD가 된다.

한 셀에 1,2,3,4 비트를 저장할 수 있는 플래시 메모리의 타입으로 SLC, MLC, TLC, QLC로 나눌 수 있다.

우리가 시중에서 사서 데스크탑에서 쓰는 흔한 SSD는 TLC 이다.

한 셀에 여러 비트를 저장할 수 있다는 점에서 높은 비트 수를 한 셀에 저장하는 타입이 좋지 않나 싶지만 오히려 거꾸로이다.

| 종류      | 풀네임               | 비트/셀 | 속도       | 수명      | 가격       | 현재 사용처                          |
| ------- | ----------------- | ---- | -------- | ------- | -------- | ------------------------------- |
| **SLC** | Single-Level Cell | 1bit | 🔥 가장 빠름 | 🔋 가장 김 | 💰 매우 비쌈 | 고급 산업용, 서버, 일부 캐시 용도로 극히 제한적 사용 |
| **MLC** | Multi-Level Cell  | 2bit | 빠름       | 김       | 비쌈       | 고급 SSD (거의 단종 추세)               |
| **TLC** | Triple-Level Cell | 3bit | 보통       | 보통      | 저렴       | ✅ **대다수 소비자 SSD**               |
| **QLC** | Quad-Level Cell   | 4bit | 느림       | 짧음      | 가장 저렴    | 용량 중시 보급형 SSD, 아카이브용            |

하나의 셀에 많은 비트를 구분해야한다면 전압을 더욱 정교하게 구분해서 조작해주어야 하기 때문에 쓰기 속도가 느려진다. 

SLC의 경우 1비트(0 or 1)만을 판단하면 되기에 정교하게 전기를 조작해줄 필요가 없지만, 비트가 늘어날 수록 전압차를 매우 잘 계산해야한다.

그런데 셀 내부 절연체는 쓰면 쓸수록 마모된다는 특징을 가진다.

0과 1을 판단하는데에는 이것이 마모된다 하더라도 둘 중 하나만을 구분하면 되는 것이니 큰 문제가 없지만 비트가 늘어나면 값을 잘못 판단하게 될 수 있다.

그렇기에 수명적인 관점에서도 한 셀에 들어가는 비트가 작아질 수록 수명이 길다.

한 셀에 비트를 줄이게 될 수록 구현해야하는 용량이 동일하다면 셀의 수가 늘어나기에 가격적으로도 당연히 비트 수가 작아질수록 비싸진다.

셀이 마모된다면 SSD의 자체적인 방식으로 망가진 셀의 정보를 다른 셀로 옮긴다.

### 플래시 메모리 저장단위

셀 -> 페이지(셀의 모임) -> 블록(페이지의 모임) -> 플레인(블록의 모임) -> 다이(플레인의 모임)

![image](https://github.com/user-attachments/assets/01ca891a-7314-4b32-8ff0-db850138154a)

### 동작 단위

읽기와 쓰기는 페이지 단위로, 삭제는 블록 단위로 이루어진다.

삭제는 블록(수백 KB수 MB) 단위로만 가능한 이유는, 플래시 메모리의 셀 구조상 전하를 주입(쓰기)하거나 측정(읽기)은 미세하게 제어할 수 있지만, 

전하를 완전히 제거(삭제)하려면 높은 전압을 걸어야 하며 이는 안정성과 전기적 제약으로 인해 블록 전체에만 적용할 수 있기 때문이다

### 페이지의 상태

- Free 상태 : 어떠한 데이터도 저장하고 있지 않은 상태
- Valid 상태 : 이미 데이터 저장하고 있는 상태
- Invalid 상태 : 쓰레기 값을 저장하고 있는 상태

### 플래시 메모리의 가비지 컬렉션

플래시 메모리는 블록 단위로만 데이터를 삭제할 수 있기에

(동일 블록 가정) 만약 어떤 페이지의 값을 수정하려고 한다면 그 페이지는 죽은 페이지로 두고 빈 페이지에 새로운 값을 넣는다.

이런 방식을 계속 쓰다보면 `죽은 페이지`가 매우 많아져 유효한 페이지 공간이 계속해서 부족해져갈 것이다.

이를 방지하기 위해 유효한 페이지들만으로 새로운 블록을 생성하고 기존의 블록을 삭제하여 공간 낭비를 방지한다.


