# CPU 구조 및 동작 프로세스 정리

## CPU 주요 구성 요소
- **ALU (Arithmetic Logic Unit)** : 계산기 역할. 산술 및 논리 연산 수행.
- **레지스터 (Register)** : CPU 내부의 매우 빠른 저장 장치.(캐시들보다 당연히 더 빠름)
  - 예: 프로그램 카운터(PC)도 레지스터 중 하나.
  - 멀티코어 환경에서는 코어마다 독립적으로 존재하며, 가장 빠르고 가까운 저장소.
- **제어장치 (Control Unit)** : 명령어 해석 및 제어신호 전송 담당. ALU, 메모리 등 하드웨어에 신호를 보냄.
- **캐시 (Cache)** : 레지스터 다음 단계의 저장 장치로, 메모리 접근보다 빠름. L1 -> L2 -> L3 순으로 속도가 느려지고 용량이 커질 수 있다.
  - **L1, L2 캐시**: 각 코어별로 존재함.
  - **L3 캐시**: 모든 코어가 공유하는 캐시로, CPU의 후방에 위치한 마지막 캐시 단계.

### 멀티 코어, 멀티 스레드라면?
| 구성 요소     | 구조 및 개수 (8코어 16스레드 기준)                                           |
|---------------|------------------------------------------------------------------------------|
| **ALU**        | 각 코어마다 최소 1개 이상 존재 → 총 8개 이상 (일반적으로 2~4개/코어)         |
| **레지스터**   | 각 코어마다 독립된 레지스터 집합 보유 → 총 8세트                            |
| **제어장치**   | 각 코어에 하나씩 존재 → 총 8개                                               |
| **L1 캐시**    | 보통 코어마다 L1d(데이터) + L1i(명령어) → 총 16개 이상                       |
| **L2 캐시**    | 일반적으로 코어별로 존재 → 총 8개                                            |
| **L3 캐시**    | 전체 코어가 공유 → 1개 (CPU 전체에서 공유하는 큰 캐시)                       |

### CPU의 쓰레드는 무엇인가?
8코어 16스레드라면 실제로는 8개의 코어가 동작하지만 OS에서는 논리 코어로 16개가 인식되는 것이다.

즉 동시에 16개의 스레드 작업을 스케줄링할 수 있다.

이렇게 코어 수보다 더 많은 쓰레드를 동시에 처리할 수있도록 하는 것이 `하이퍼 스레딩`이다.

코어 내부의 여러 유닛들은 코어당 하나의 쓰레드로는 전부 가동되지 않기 때문에, 즉 가장 바쁠 때 놀게하지 않기 위해 코어 내부에 논리적 다중 스레드 구조를 만들어 코어가 최대 바쁘게 돌아갈 때 유닛의 활용도를 최대한으로 
올리기 위함이다.

### ALU(계산 회로)
입력 관점에서 ALU는 레지스터로부터 피연산자를 받아들이고, 제어장치로부터 제어신호를 받아들인다.

출력 관점에서 ALU는 계산 결괏값을 다시 레지스터에 보내고, 연산결과에 대한 부가정보를 플래그란 형태로 플래그 레지스터에 보낸다.

부가정보에는 예를 들어 양수, 음수가 있다.(캐리 발생 여부, 오버플로우 여부 또한 포함될 수 있다.)

#### 왜 결괏값에 양,음수를 포함하지 않고 플래그를 활용하는가?
예를 들어 결과가 음수이면 점프하라는 명령을 처리할 때,
매번 결과 값의 최상위 비트를 꺼내서 비교하는 건 귀찮고 느리다.

### 제어장치
제어장치는 메인보드에 있는 클럭 제너레이터에서 생성된 클럭 신호를 클럭 주기에 따라 받고, 명령어 레지스터(Instruction Register, IR)로부터 해석할 명령어를 받게 된다. 또한 입출력 장치를 비롯한 다른 하드웨어에서의 제어버스(메인보드 제어신호 전용회로)를 통해 제어신호를 받기도 한다.

제어장치는 이를 해석하여 제어신호들을 보낸다. 이 제어신호들은 CPU내부(ALU, 레지스터)로도 외부로도 갈 수 있다.(메모리, 입출력장치)

#### 클럭
우리가 흔히 CPU 사양에서 언급하는 클럭은 이 제어장치와 연관이 깊다. 제어장치의 동작은 이 클럭 신호에 맞추어 동작한다. 만약 5200MHz 클럭을 가진 CPU라면 그리고 그 CPU가 8코어라면 각 코어마다의 제어장치들은 1초에 52억번(클럭 주기) 명령을 실행할 수 있는 기회를 가진다. 

컴덕들이 즐겨 하는 CPU 오버클럭이란 CPU 코어의 최대 클럭을 제조사가 설계한 것보다 최대 클럭을 의도적으로 더 높게 설정하여 CPU의 처리량을 늘리려는 목적이다.

모니터링 시스템에서 현재 내 코어가 어떤 벤치마크 프로그램에 의해 모든 코어가 5200MHz으로 가동된다면 이는 1초에 52억번 명령을 수행할 준비중이라는 것이다.

평소에는 1400MHz로 돌고있다. 그렇다는 것은 코어가 1초에 14억번 명령을 수행할 준비중이라는 것이다. 그렇다 최대 클럭으로 항상 동작하지 않고 CPU는 동적으로 클럭을 구성한다.

클럭이 동적으로 바뀌는 원인은 OS가 아니라 CPU 자신만의 로직이다. 전력과 발열 상황에 따라 클럭을 조절하며 CPU 내부의 성능 카운터인 `PMU`에 의해 부하에 대한 판단을 할 수 있다.

### 레지스터 (Register)

레지스터는 **CPU 내부에 존재하는 가장 빠른 저장 장치**이며,  
모든 연산과 명령 실행은 이 레지스터를 중심으로 진행된다.  
속도 면에서는 **캐시보다도 빠르고**,  
위치상으로는 **ALU나 제어장치 바로 옆**에 있어 데이터 접근 시간이 매우 짧다.

- **초고속, 초소용량 저장 공간** (보통 수십~수백 개, 총 용량은 수백 바이트 수준)
- **특정 용도에 따라 이름과 기능이 다름**
- **각 코어마다 독립적으로 존재** (멀티코어 CPU라면 레지스터 세트도 코어마다 있음)

CPU는 **메모리보다 레지스터에서 데이터를 읽고 쓰는 속도**가 훨씬 빠르기 때문에,  
모든 계산은 가능하면 **레지스터에 값을 올려놓고 처리**하려고 한다.  
실제로 명령어 대부분은 **레지스터 간 이동이나 연산**을 전제로 한다.

#### 주요 레지스터 종류

| 레지스터 | 설명 |
|----------|------|
| **일반 목적 레지스터 (General Purpose Register)** | 데이터 연산에 사용되는 범용 저장소 (예: x86에서 `eax`, `ebx` 등) |
| **명령어 레지스터 (Instruction Register, IR)** | 현재 실행 중인 명령어 자체를 저장 |
| **프로그램 카운터 (Program Counter, PC)** | 다음에 실행할 명령어의 메모리 주소를 가리킴 |
| **스택 포인터 (Stack Pointer, SP)** | 현재 스택의 최상단 위치를 가리킴 |
| **상태 레지스터 / 플래그 레지스터 (Flags Register)** | ALU 결과에 대한 상태(예: 0인지, 음수인지, 캐리 발생 여부 등)를 저장 |
| **인덱스/포인터 레지스터** | 메모리 주소 계산, 배열 인덱싱 등에 사용됨 |

CPU는 **메모리보다 레지스터에서 데이터를 읽고 쓰는 속도**가 훨씬 빠르기 때문에,  
모든 계산은 가능하면 **레지스터에 값을 올려놓고 처리**하려고 한다.  
실제로 명령어 대부분은 **레지스터 간 이동이나 연산**을 전제로 한다.

## 최근의 CPU로 알아보자.
### AMD 9800X3D 구조 특징(내가 최근 구매한 CPU이기에 이를 활용해서 공부해보자.)
- 게이밍 최적화 CPU인 9800X3D는 이전 non-X3D 대비 위로 약간 더 뚱뚱해진 구조를 가짐.
- CPU는 크게 `뚜껑(히트스프레더) - 코어 + 캐시 - 기판` 구조로 되어 있음.
- 이 CPU는 **뚜껑과 코어+캐시 사이에 L3 V-Cache 다이**를 수직 적층(3D Stacking)함으로써 L3 캐시 용량을 크게 확장함.
- 코어별로 독립된 레지스터, L1, L2 캐시와 달리 **L3는 모든 코어가 공유**하는 캐시이기 때문에 이러한 설계가 가능함.

Ryzen 9 9800X3D처럼 L3 캐시를 대용량으로 탑재한 게이밍 CPU 구조는 게임에서 자주 참조되는 데이터를 메모리보다 훨씬 빠른 캐시에 저장함으로써 지연 시간을 최소화하고 프레임 일관성을 크게 향상시키는 데 효과적이다. 

특히 게임 엔진은 반복적으로 동일한 연산과 데이터를 요구하므로, L3 캐시 용량이 클수록 CPU와 메모리 간의 병목이 줄어들어 성능 최적화에 유리하다. 

그러나 이러한 구조는 칩 면적 증가, 발열 관리, 캐시 일관성 유지, 설계 복잡도 등의 이유로 구현이 매우 까다롭고, 특히 3D V-Cache 기술처럼 수직적 캐시 적층을 통해 이를 해결하려면 고도의 반도체 공정 기술과 정밀한 전력·신호 설계가 필수적이다.
(AMD는 짱이다!)

## CPU 명령어 실행 프로세스 (Instruction Cycle)

1. **Program Counter(PC)를 확인**
   - 제어장치가 PC를 참조하여 다음 실행할 명령어의 메모리 주소 확인
2. **명령어 Fetch 시도**
   - 우선 L1 I-Cache에서 해당 주소의 명령어를 찾음
   - L1에 없으면 L2 → L3 → RAM 순으로 탐색
3. **명령어를 레지스터에 로드**
4. **제어장치가 명령어를 해석(Decode)**
   - 예: 이 명령어는 덧셈인가? 점프인가?
5. **명령어 실행**
   - ALU를 호출하거나, 메모리 접근 등 해당 동작 수행
6. **Program Counter를 업데이트**
   - 일반적으로 +1 증가하거나, 점프 명령일 경우 새 주소로 설정
7. **다음 명령어로 이동**

---

## 해석 및 의문

CPU 제어장치는 자신의 작업 흐름을 PC(Program Counter)에 따라 진행하는 구조이다. **하지만 PC의 값은 운영체제가 주도적으로 제어**한다.

- 운영체제는 CPU와의 유일한 접점인 PC를 통해 CPU의 명령 실행 순서를 조율함.
- CPU는 PC가 가리키는 주소대로 **명령어를 해석하고 실행하는 순수한 실행 장치**일 뿐이다.
- 결과적으로 **CPU는 OS가 넣어준 계획대로 동작하는 하드웨어 처리기**이며,
  CPU는 계획을 짜지 않고, 오로지 실행만 한다는 점에서 일종의 '노예'처럼 동작한다고 볼 수 있다.

이러한 구조는 컨텍스트 스위칭(context switching)과도 연결된다. 운영체제가 각 프로세스의 PC 값을 저장하고, CPU에 할당될 때 해당 PC 값을 복원함으로써 프로세스의 명령 흐름을 제어할 수 있다.

여기서 자연스럽게 나올 수 있는 질문이, “그럼 여러 쓰레드 작업을 GPU로 돌리면 더 빠른 거 아님?”인데, 사실 그건 안 맞는 얘기다. GPU는 애초에 구조가 다르다. 똑같은 일을 수천 개의 데이터에 동시에 반복할 때 잘 맞는 도구지, 서로 다른 일을 막 시키는 데는 안 어울린다. CPU 쓰레드는 각자 다른 일, 다른 흐름, 다른 조건문 타고 돌아가는데, GPU는 그런 복잡한 흐름엔 약하다. GPU는 “야, 이거 100만 번 똑같이 해봐” 할 땐 엄청 빠르지만, “얘는 이거 하고, 쟤는 저거 하다가 상황 봐서 이거 해” 같은 건 잘 못한다.

결국 지금 우리가 쓰는 일반적인 쓰레드 실행이나 OS 수준 작업은, 아직까지는 CPU가 제일 잘한다. GPU는 병렬계의 괴물이지만, 그 괴물은 단순한 반복작업에 최적화돼 있는 거고, 운영체제의 쓰레드 제어 같은 유연한 작업은 딱히 그 괴물한테 어울리는 일이 아니다.

즉 질문에 포함된 `여러 쓰레드 작업`은 GPU가 소화할 수 없는 복잡한 작업이라는 것이다. 

GPU는 그렇기에 화면 출력과 같은 `같은 작업 고반복`에 사용된다.

### 왜 모니터 화면 출력은 같은 작업 고반복에 해당할까?
1920 x 1080 FHD 스펙의 144hz를 지원하는 모니터를 사용한다고 가정해보자.

**1920 x 1080, 144Hz라면:** 1920 × 1080 × 144 = 약 298,598,400개

즉 1초에 약 3억 개의 픽셀을 계산해서 화면에 뿌려야한다.

분명 픽셀마다 다른 RGB를 보여주고 같은 픽셀의 다음 RGB값이 다르다.

GPU의 같은 작업 고반복이라는 특징에서 같은 작업의 뜻은, GPU 연산이 항상 같은 결과를 내보내는 것은 아니며 하지만 연산과정은 동일하다는 것에 있다. 

GPU는 같은 함수를 3억번 호출해야할 때 이를 하나씩 고속으로 순차적으로 처리하는 것이 아니라 **동시에 여러개를 한번에 처리하는 것이다.** 

---

## 정리
- CPU는 ALU, 레지스터, 캐시, 제어장치 등으로 구성되어 있고, 명령어 실행은 명확한 fetch-decode-execute 흐름을 따른다.
- L1/L2는 코어별로, L3는 코어공유로 존재하며, AMD의 X3D 시리즈는 L3 캐시를 물리적으로 확장해 성능을 끌어올린다.
- 명령어 흐름의 중심은 PC이며, 그 PC조차도 운영체제가 관리함으로써 전체 프로그램 흐름은 OS가 주도한다.
- CPU는 명령어 해석과 실행에만 충실한 구조다.

