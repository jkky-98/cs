# CPU 구조 및 동작 프로세스 정리

## CPU 주요 구성 요소
- **ALU (Arithmetic Logic Unit)** : 계산기 역할. 산술 및 논리 연산 수행.
- **레지스터 (Register)** : CPU 내부의 매우 빠른 저장 장치.(캐시들보다 당연히 더 빠름)
  - 예: 프로그램 카운터(PC)도 레지스터 중 하나.
  - 멀티코어 환경에서는 코어마다 독립적으로 존재하며, 가장 빠르고 가까운 저장소.
- **제어장치 (Control Unit)** : 명령어 해석 및 제어신호 전송 담당. ALU, 메모리 등 하드웨어에 신호를 보냄.
- **캐시 (Cache)** : 레지스터 다음 단계의 저장 장치로, 메모리 접근보다 빠름. L1 -> L2 -> L3 순으로 속도가 느려지고 용량이 커질 수 있다.
  - **L1, L2 캐시**: 각 코어별로 존재함.
  - **L3 캐시**: 모든 코어가 공유하는 캐시로, CPU의 후방에 위치한 마지막 캐시 단계.

## 최근의 CPU로 알아보자.
### AMD 9800X3D 구조 특징(내가 최근 구매한 CPU이기에 이를 활용해서 공부해보자.)
- 게이밍 최적화 CPU인 9800X3D는 이전 non-X3D 대비 위로 약간 더 뚱뚱해진 구조를 가짐.
- CPU는 크게 `뚜껑(히트스프레더) - 코어 + 캐시 - 기판` 구조로 되어 있음.
- 이 CPU는 **뚜껑과 코어+캐시 사이에 L3 V-Cache 다이**를 수직 적층(3D Stacking)함으로써 L3 캐시 용량을 크게 확장함.
- 코어별로 독립된 레지스터, L1, L2 캐시와 달리 **L3는 모든 코어가 공유**하는 캐시이기 때문에 이러한 설계가 가능함.

Ryzen 9 9800X3D처럼 L3 캐시를 대용량으로 탑재한 게이밍 CPU 구조는 게임에서 자주 참조되는 데이터를 메모리보다 훨씬 빠른 캐시에 저장함으로써 지연 시간을 최소화하고 프레임 일관성을 크게 향상시키는 데 효과적이다. 

특히 게임 엔진은 반복적으로 동일한 연산과 데이터를 요구하므로, L3 캐시 용량이 클수록 CPU와 메모리 간의 병목이 줄어들어 성능 최적화에 유리하다. 

그러나 이러한 구조는 칩 면적 증가, 발열 관리, 캐시 일관성 유지, 설계 복잡도 등의 이유로 구현이 매우 까다롭고, 특히 3D V-Cache 기술처럼 수직적 캐시 적층을 통해 이를 해결하려면 고도의 반도체 공정 기술과 정밀한 전력·신호 설계가 필수적이다.
(AMD는 짱이다!)
---

## CPU 명령어 실행 프로세스 (Instruction Cycle)

1. **Program Counter(PC)를 확인**
   - 제어장치가 PC를 참조하여 다음 실행할 명령어의 메모리 주소 확인
2. **명령어 Fetch 시도**
   - 우선 L1 I-Cache에서 해당 주소의 명령어를 찾음
   - L1에 없으면 L2 → L3 → RAM 순으로 탐색
3. **명령어를 레지스터에 로드**
4. **제어장치가 명령어를 해석(Decode)**
   - 예: 이 명령어는 덧셈인가? 점프인가?
5. **명령어 실행**
   - ALU를 호출하거나, 메모리 접근 등 해당 동작 수행
6. **Program Counter를 업데이트**
   - 일반적으로 +1 증가하거나, 점프 명령일 경우 새 주소로 설정
7. **다음 명령어로 이동**

---

## 해석 및 의문

CPU 제어장치는 자신의 작업 흐름을 PC(Program Counter)에 따라 진행하는 구조이다. **하지만 PC의 값은 운영체제가 주도적으로 제어**한다.

- 운영체제는 CPU와의 유일한 접점인 PC를 통해 CPU의 명령 실행 순서를 조율함.
- CPU는 PC가 가리키는 주소대로 **명령어를 해석하고 실행하는 순수한 실행 장치**일 뿐이다.
- 결과적으로 **CPU는 OS가 넣어준 계획대로 동작하는 하드웨어 처리기**이며,
  CPU는 계획을 짜지 않고, 오로지 실행만 한다는 점에서 일종의 '노예'처럼 동작한다고 볼 수 있다.

이러한 구조는 컨텍스트 스위칭(context switching)과도 연결된다. 운영체제가 각 프로세스의 PC 값을 저장하고, CPU에 할당될 때 해당 PC 값을 복원함으로써 프로세스의 명령 흐름을 제어할 수 있다.

여기서 자연스럽게 나올 수 있는 질문이, “그럼 여러 쓰레드 작업을 GPU로 돌리면 더 빠른 거 아님?”인데, 사실 그건 안 맞는 얘기다. GPU는 애초에 구조가 다르다. 똑같은 일을 수천 개의 데이터에 동시에 반복할 때 잘 맞는 도구지, 서로 다른 일을 막 시키는 데는 안 어울린다. CPU 쓰레드는 각자 다른 일, 다른 흐름, 다른 조건문 타고 돌아가는데, GPU는 그런 복잡한 흐름엔 약하다. GPU는 “야, 이거 100만 번 똑같이 해봐” 할 땐 엄청 빠르지만, “얘는 이거 하고, 쟤는 저거 하다가 상황 봐서 이거 해” 같은 건 잘 못한다.

결국 지금 우리가 쓰는 일반적인 쓰레드 실행이나 OS 수준 작업은, 아직까지는 CPU가 제일 잘한다. GPU는 병렬계의 괴물이지만, 그 괴물은 단순한 반복작업에 최적화돼 있는 거고, 운영체제의 쓰레드 제어 같은 유연한 작업은 딱히 그 괴물한테 어울리는 일이 아니다.

즉 질문에 포함된 `여러 쓰레드 작업`은 GPU가 소화할 수 없는 복잡한 작업이라는 것이다. 

GPU는 그렇기에 화면 출력과 같은 `같은 작업 고반복`에 사용된다.

### 왜 모니터 화면 출력은 같은 작업 고반복에 해당할까?
1920 x 1080 FHD 스펙의 144hz를 지원하는 모니터를 사용한다고 가정해보자.

**1920 x 1080, 144Hz라면:** 1920 × 1080 × 144 = 약 298,598,400개

즉 1초에 약 3억 개의 픽셀을 계산해서 화면에 뿌려야한다.

분명 픽셀마다 다른 RGB를 보여주고 같은 픽셀의 다음 RGB값이 다르다.

GPU 연산이 같은 결과를 내보내는 것은 아니다. 하지만 연산과정은 동일하다. 

GPU는 같은 함수를 3억번 호출해야할 때 이를 하나씩 고속으로 순차적으로 처리하는 것이 아니라 **동시에 여러개를 한번에 처리하는 것이다.** 

---

## 정리
- CPU는 ALU, 레지스터, 캐시, 제어장치 등으로 구성되어 있고, 명령어 실행은 명확한 fetch-decode-execute 흐름을 따른다.
- L1/L2는 코어별로, L3는 코어공유로 존재하며, AMD의 X3D 시리즈는 L3 캐시를 물리적으로 확장해 성능을 끌어올린다.
- 명령어 흐름의 중심은 PC이며, 그 PC조차도 운영체제가 관리함으로써 전체 프로그램 흐름은 OS가 주도한다.
- CPU는 명령어 해석과 실행에만 충실한 구조다.

